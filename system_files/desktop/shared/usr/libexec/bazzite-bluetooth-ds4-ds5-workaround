#!/usr/bin/python

"""
# Script Name: bazzite-bluetooth-ds4-ds5-workaround
# Author: https://github.com/thekk1
# Version: 1.6
#
# Related issues:
# https://github.com/ublue-os/bazzite/issues/1289
# https://github.com/ValveSoftware/steam-for-linux/issues/8678
#
# Description:
# This script monitors connected PS4 and PS5 gamepad devices and disconnects
# the Bluetooth connection if specific button combinations are detected (Home and Triangle buttons).
# The script handles background processes for each device and maintains a record of process IDs
# to ensure proper cleanup of processes associated with devices that are no longer present.
#
# This script should be removed if there is a native solution under one of the mentioned issues.
#
# Usage:
# ./bazzite-bluetooth-ds4-ds5-workaround <device_mac_address>

"""
# See https://gist.github.com/noohgnas/7c896791d437e51122c59fe9576a1bcf for reference
from concurrent.futures import thread
import glob
import multiprocessing
import re
import struct
import subprocess
import sys

from threading import Thread
from time import sleep


class KeyStatus:
    def __init__(self) -> None:
        self.home: bool = False
        self.triangle: bool = False
        self.other: set[int] = set()


GAMEPAD_KEYS = {
    "HOME": [
        316,  # Dualshock
    ],
    "TRIANGLE": [
        307,  # Dualshock
    ],
}

EV_KEY = 1


def trigger_callback(device_mac: str):
    """Action to realize when HOME + TRIANGLE is held at the same time"""
    # Get bluetooth adapters
    p = subprocess.Popen(
        ["/usr/bin/bluetoothctl", "list"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    p.wait()
    adapt_strlines = p.stdout
    if adapt_strlines is None:
        print("ERROR: No adapters detected")
        return

    for adap in adapt_strlines:
        print(f"DEBUG: {adap}")
        adap = adap.strip().split(" ", maxsplit=2)[1]
        p2 = subprocess.Popen(
            ["/usr/bin/bash", "-c", f"""echo -e "select {adap}\ndisconnect {device_mac}" | bluetoothctl """],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
        )
        p2.wait()


def get_event_path(mac: str) -> str | None:
    """Obtain the /dev/input/eventX path for a bluetooth
    Returns:
        str: path address
    """
    res: str | None = None
    mac = mac.lower()
    proc = subprocess.Popen(
        [
            "/usr/bin/udevadm",
            "trigger",
            "-c",
            "add",
            f"--attr-match=uniq={mac}",
            "--dry-run",
            "--verbose",
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    proc.wait()
    if proc.stdout is None:
        return res
    paths = proc.stdout.readlines()
    for path in paths:
        path = path.strip()
        with open(f"{path}/name") as f:
            contents = f.read().strip()
            if re.match(r"^(?:Dualsense )?Wireless Controller$", contents) is not None:
                ev_name = glob.glob(f"{path}/event*")[0].rstrip("/").split("/")[-1]
                res = f"/dev/input/{ev_name}"
                break

    return res


def main(argv: list[str]):
    if len(argv[1:]) != 1:
        print("ERROR: Missing argument", file=sys.stderr)
        exit(1)

    device_mac = argv[1]
    if device_mac is None or device_mac == "":
        print("ERROR: Incorrect device bluetooth mac address", file=sys.stderr)
        exit(1)

    global keys_status
    keys_status = KeyStatus()

    gamepad_mac = get_event_path(device_mac)
    if gamepad_mac is None:
        print("ERROR: Incorrect device bluetooth mac address", file=sys.stderr)
        exit(1)

    # long int, long int, unsigned short, unsigned short, unsigned int
    FORMAT = "llHHI"
    EVENT_SIZE = struct.calcsize(FORMAT)

    # open file in binary mode
    in_file = open(gamepad_mac, "rb")

    event = in_file.read(EVENT_SIZE)

    while event:
        (_tv_sec, _tv_usec, type, code, value) = struct.unpack(FORMAT, event)

        if type == EV_KEY:
            if code in GAMEPAD_KEYS["HOME"]:
                keys_status.home = value == 1
            elif code in GAMEPAD_KEYS["TRIANGLE"]:
                keys_status.triangle = value == 1
            else:
                (
                    keys_status.other.add(code)
                    if value == 1
                    else keys_status.other.remove(code)
                )

            # print(
            #     f"home: {keys_status.home}, triangle: {keys_status.triangle}, other: {keys_status.other}",
            # )
            if (
                value == 1
                and keys_status.home
                and keys_status.triangle
                and len(keys_status.other) <= 0
            ):
                #### Here we manage what happens when the HOME TRIANGLE is pressed
                print("HOME + TRIANGLE detected")
                trigger_callback(device_mac)
        event = in_file.read(EVENT_SIZE)

    in_file.close()


if __name__ == "__main__":
    main(sys.argv)
